// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// RequestContextBatchState is a type alias that represents a request batch status as a byte
enum Irismod_Service_RequestContextBatchState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// BATCH_RUNNING defines the running batch status.
  case batchRunning // = 0

  /// BATCH_COMPLETED defines the completed batch status.
  case batchCompleted // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .batchRunning
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .batchRunning
    case 1: self = .batchCompleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .batchRunning: return 0
    case .batchCompleted: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Irismod_Service_RequestContextBatchState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Irismod_Service_RequestContextBatchState] = [
    .batchRunning,
    .batchCompleted,
  ]
}

#endif  // swift(>=4.2)

/// RequestContextState is a type alias that represents a request status as a byte
enum Irismod_Service_RequestContextState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// RUNNING defines the running request context status
  case running // = 0

  /// PAUSED defines the paused request context status
  case paused // = 1

  /// COMPLETED defines the completed request context status
  case completed // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .running
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .running
    case 1: self = .paused
    case 2: self = .completed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .running: return 0
    case .paused: return 1
    case .completed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Irismod_Service_RequestContextState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Irismod_Service_RequestContextState] = [
    .running,
    .paused,
    .completed,
  ]
}

#endif  // swift(>=4.2)

/// ServiceDefinition defines a standard for service definition
struct Irismod_Service_ServiceDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var description_p: String = String()

  var tags: [String] = []

  var author: String = String()

  var authorDescription: String = String()

  var schemas: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ServiceBinding defines a standard for service binding
struct Irismod_Service_ServiceBinding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceName: String = String()

  var provider: String = String()

  var deposit: [Cosmos_Base_V1beta1_Coin] = []

  var pricing: String = String()

  var qos: UInt64 = 0

  var options: String = String()

  var available: Bool = false

  var disabledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _disabledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_disabledTime = newValue}
  }
  /// Returns true if `disabledTime` has been explicitly set.
  var hasDisabledTime: Bool {return self._disabledTime != nil}
  /// Clears the value of `disabledTime`. Subsequent reads from it will return its default value.
  mutating func clearDisabledTime() {self._disabledTime = nil}

  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _disabledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// RequestContext defines a standard for request context
struct Irismod_Service_RequestContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceName: String {
    get {return _storage._serviceName}
    set {_uniqueStorage()._serviceName = newValue}
  }

  var providers: [String] {
    get {return _storage._providers}
    set {_uniqueStorage()._providers = newValue}
  }

  var consumer: String {
    get {return _storage._consumer}
    set {_uniqueStorage()._consumer = newValue}
  }

  var input: String {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  var serviceFeeCap: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._serviceFeeCap}
    set {_uniqueStorage()._serviceFeeCap = newValue}
  }

  var moduleName: String {
    get {return _storage._moduleName}
    set {_uniqueStorage()._moduleName = newValue}
  }

  var timeout: Int64 {
    get {return _storage._timeout}
    set {_uniqueStorage()._timeout = newValue}
  }

  var repeated: Bool {
    get {return _storage._repeated}
    set {_uniqueStorage()._repeated = newValue}
  }

  var repeatedFrequency: UInt64 {
    get {return _storage._repeatedFrequency}
    set {_uniqueStorage()._repeatedFrequency = newValue}
  }

  var repeatedTotal: Int64 {
    get {return _storage._repeatedTotal}
    set {_uniqueStorage()._repeatedTotal = newValue}
  }

  var batchCounter: UInt64 {
    get {return _storage._batchCounter}
    set {_uniqueStorage()._batchCounter = newValue}
  }

  var batchRequestCount: UInt32 {
    get {return _storage._batchRequestCount}
    set {_uniqueStorage()._batchRequestCount = newValue}
  }

  var batchResponseCount: UInt32 {
    get {return _storage._batchResponseCount}
    set {_uniqueStorage()._batchResponseCount = newValue}
  }

  var batchResponseThreshold: UInt32 {
    get {return _storage._batchResponseThreshold}
    set {_uniqueStorage()._batchResponseThreshold = newValue}
  }

  var responseThreshold: UInt32 {
    get {return _storage._responseThreshold}
    set {_uniqueStorage()._responseThreshold = newValue}
  }

  var batchState: Irismod_Service_RequestContextBatchState {
    get {return _storage._batchState}
    set {_uniqueStorage()._batchState = newValue}
  }

  var state: Irismod_Service_RequestContextState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request defines a standard for request
struct Irismod_Service_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var serviceName: String = String()

  var provider: String = String()

  var consumer: String = String()

  var input: String = String()

  var serviceFee: [Cosmos_Base_V1beta1_Coin] = []

  var requestHeight: Int64 = 0

  var expirationHeight: Int64 = 0

  var requestContextID: String = String()

  var requestContextBatchCounter: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CompactRequest defines a standard for compact request
struct Irismod_Service_CompactRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestContextID: String = String()

  var requestContextBatchCounter: UInt64 = 0

  var provider: String = String()

  var serviceFee: [Cosmos_Base_V1beta1_Coin] = []

  var requestHeight: Int64 = 0

  var expirationHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response defines a standard for response
struct Irismod_Service_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var provider: String = String()

  var consumer: String = String()

  var result: String = String()

  var output: String = String()

  var requestContextID: String = String()

  var requestContextBatchCounter: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Pricing defines a standard for service pricing
struct Irismod_Service_Pricing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: [Cosmos_Base_V1beta1_Coin] = []

  var promotionsByTime: [Irismod_Service_PromotionByTime] = []

  var promotionsByVolume: [Irismod_Service_PromotionByVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PromotionByTime defines a standard for service promotion by time
struct Irismod_Service_PromotionByTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  var discount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// PromotionByVolume defines a standard for service promotion by volume
struct Irismod_Service_PromotionByVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volume: UInt64 = 0

  var discount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Params defines service module's parameters
struct Irismod_Service_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxRequestTimeout: Int64 = 0

  var minDepositMultiple: Int64 = 0

  var minDeposit: [Cosmos_Base_V1beta1_Coin] = []

  var serviceFeeTax: String = String()

  var slashFraction: String = String()

  var complaintRetrospect: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _complaintRetrospect ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_complaintRetrospect = newValue}
  }
  /// Returns true if `complaintRetrospect` has been explicitly set.
  var hasComplaintRetrospect: Bool {return self._complaintRetrospect != nil}
  /// Clears the value of `complaintRetrospect`. Subsequent reads from it will return its default value.
  mutating func clearComplaintRetrospect() {self._complaintRetrospect = nil}

  var arbitrationTimeLimit: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _arbitrationTimeLimit ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_arbitrationTimeLimit = newValue}
  }
  /// Returns true if `arbitrationTimeLimit` has been explicitly set.
  var hasArbitrationTimeLimit: Bool {return self._arbitrationTimeLimit != nil}
  /// Clears the value of `arbitrationTimeLimit`. Subsequent reads from it will return its default value.
  mutating func clearArbitrationTimeLimit() {self._arbitrationTimeLimit = nil}

  var txSizeLimit: UInt64 = 0

  var baseDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _complaintRetrospect: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _arbitrationTimeLimit: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "irismod.service"

extension Irismod_Service_RequestContextBatchState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BATCH_RUNNING"),
    1: .same(proto: "BATCH_COMPLETED"),
  ]
}

extension Irismod_Service_RequestContextState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNNING"),
    1: .same(proto: "PAUSED"),
    2: .same(proto: "COMPLETED"),
  ]
}

extension Irismod_Service_ServiceDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceDefinition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "tags"),
    4: .same(proto: "author"),
    5: .standard(proto: "author_description"),
    6: .same(proto: "schemas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeRepeatedStringField(value: &self.tags)
      case 4: try decoder.decodeSingularStringField(value: &self.author)
      case 5: try decoder.decodeSingularStringField(value: &self.authorDescription)
      case 6: try decoder.decodeSingularStringField(value: &self.schemas)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 3)
    }
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 4)
    }
    if !self.authorDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.authorDescription, fieldNumber: 5)
    }
    if !self.schemas.isEmpty {
      try visitor.visitSingularStringField(value: self.schemas, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_ServiceDefinition, rhs: Irismod_Service_ServiceDefinition) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.author != rhs.author {return false}
    if lhs.authorDescription != rhs.authorDescription {return false}
    if lhs.schemas != rhs.schemas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_ServiceBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceBinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .same(proto: "provider"),
    3: .same(proto: "deposit"),
    4: .same(proto: "pricing"),
    5: .same(proto: "qos"),
    6: .same(proto: "options"),
    7: .same(proto: "available"),
    8: .standard(proto: "disabled_time"),
    9: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.serviceName)
      case 2: try decoder.decodeSingularStringField(value: &self.provider)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.deposit)
      case 4: try decoder.decodeSingularStringField(value: &self.pricing)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.qos)
      case 6: try decoder.decodeSingularStringField(value: &self.options)
      case 7: try decoder.decodeSingularBoolField(value: &self.available)
      case 8: try decoder.decodeSingularMessageField(value: &self._disabledTime)
      case 9: try decoder.decodeSingularStringField(value: &self.owner)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 2)
    }
    if !self.deposit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deposit, fieldNumber: 3)
    }
    if !self.pricing.isEmpty {
      try visitor.visitSingularStringField(value: self.pricing, fieldNumber: 4)
    }
    if self.qos != 0 {
      try visitor.visitSingularUInt64Field(value: self.qos, fieldNumber: 5)
    }
    if !self.options.isEmpty {
      try visitor.visitSingularStringField(value: self.options, fieldNumber: 6)
    }
    if self.available != false {
      try visitor.visitSingularBoolField(value: self.available, fieldNumber: 7)
    }
    if let v = self._disabledTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_ServiceBinding, rhs: Irismod_Service_ServiceBinding) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.deposit != rhs.deposit {return false}
    if lhs.pricing != rhs.pricing {return false}
    if lhs.qos != rhs.qos {return false}
    if lhs.options != rhs.options {return false}
    if lhs.available != rhs.available {return false}
    if lhs._disabledTime != rhs._disabledTime {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_RequestContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .same(proto: "providers"),
    3: .same(proto: "consumer"),
    4: .same(proto: "input"),
    5: .standard(proto: "service_fee_cap"),
    6: .standard(proto: "module_name"),
    7: .same(proto: "timeout"),
    8: .same(proto: "repeated"),
    9: .standard(proto: "repeated_frequency"),
    10: .standard(proto: "repeated_total"),
    11: .standard(proto: "batch_counter"),
    12: .standard(proto: "batch_request_count"),
    13: .standard(proto: "batch_response_count"),
    14: .standard(proto: "batch_response_threshold"),
    15: .standard(proto: "response_threshold"),
    16: .standard(proto: "batch_state"),
    17: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _serviceName: String = String()
    var _providers: [String] = []
    var _consumer: String = String()
    var _input: String = String()
    var _serviceFeeCap: [Cosmos_Base_V1beta1_Coin] = []
    var _moduleName: String = String()
    var _timeout: Int64 = 0
    var _repeated: Bool = false
    var _repeatedFrequency: UInt64 = 0
    var _repeatedTotal: Int64 = 0
    var _batchCounter: UInt64 = 0
    var _batchRequestCount: UInt32 = 0
    var _batchResponseCount: UInt32 = 0
    var _batchResponseThreshold: UInt32 = 0
    var _responseThreshold: UInt32 = 0
    var _batchState: Irismod_Service_RequestContextBatchState = .batchRunning
    var _state: Irismod_Service_RequestContextState = .running

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _serviceName = source._serviceName
      _providers = source._providers
      _consumer = source._consumer
      _input = source._input
      _serviceFeeCap = source._serviceFeeCap
      _moduleName = source._moduleName
      _timeout = source._timeout
      _repeated = source._repeated
      _repeatedFrequency = source._repeatedFrequency
      _repeatedTotal = source._repeatedTotal
      _batchCounter = source._batchCounter
      _batchRequestCount = source._batchRequestCount
      _batchResponseCount = source._batchResponseCount
      _batchResponseThreshold = source._batchResponseThreshold
      _responseThreshold = source._responseThreshold
      _batchState = source._batchState
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._serviceName)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._providers)
        case 3: try decoder.decodeSingularStringField(value: &_storage._consumer)
        case 4: try decoder.decodeSingularStringField(value: &_storage._input)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._serviceFeeCap)
        case 6: try decoder.decodeSingularStringField(value: &_storage._moduleName)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._timeout)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._repeated)
        case 9: try decoder.decodeSingularUInt64Field(value: &_storage._repeatedFrequency)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._repeatedTotal)
        case 11: try decoder.decodeSingularUInt64Field(value: &_storage._batchCounter)
        case 12: try decoder.decodeSingularUInt32Field(value: &_storage._batchRequestCount)
        case 13: try decoder.decodeSingularUInt32Field(value: &_storage._batchResponseCount)
        case 14: try decoder.decodeSingularUInt32Field(value: &_storage._batchResponseThreshold)
        case 15: try decoder.decodeSingularUInt32Field(value: &_storage._responseThreshold)
        case 16: try decoder.decodeSingularEnumField(value: &_storage._batchState)
        case 17: try decoder.decodeSingularEnumField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._serviceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serviceName, fieldNumber: 1)
      }
      if !_storage._providers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._providers, fieldNumber: 2)
      }
      if !_storage._consumer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consumer, fieldNumber: 3)
      }
      if !_storage._input.isEmpty {
        try visitor.visitSingularStringField(value: _storage._input, fieldNumber: 4)
      }
      if !_storage._serviceFeeCap.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._serviceFeeCap, fieldNumber: 5)
      }
      if !_storage._moduleName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moduleName, fieldNumber: 6)
      }
      if _storage._timeout != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeout, fieldNumber: 7)
      }
      if _storage._repeated != false {
        try visitor.visitSingularBoolField(value: _storage._repeated, fieldNumber: 8)
      }
      if _storage._repeatedFrequency != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._repeatedFrequency, fieldNumber: 9)
      }
      if _storage._repeatedTotal != 0 {
        try visitor.visitSingularInt64Field(value: _storage._repeatedTotal, fieldNumber: 10)
      }
      if _storage._batchCounter != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._batchCounter, fieldNumber: 11)
      }
      if _storage._batchRequestCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._batchRequestCount, fieldNumber: 12)
      }
      if _storage._batchResponseCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._batchResponseCount, fieldNumber: 13)
      }
      if _storage._batchResponseThreshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._batchResponseThreshold, fieldNumber: 14)
      }
      if _storage._responseThreshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._responseThreshold, fieldNumber: 15)
      }
      if _storage._batchState != .batchRunning {
        try visitor.visitSingularEnumField(value: _storage._batchState, fieldNumber: 16)
      }
      if _storage._state != .running {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_RequestContext, rhs: Irismod_Service_RequestContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serviceName != rhs_storage._serviceName {return false}
        if _storage._providers != rhs_storage._providers {return false}
        if _storage._consumer != rhs_storage._consumer {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._serviceFeeCap != rhs_storage._serviceFeeCap {return false}
        if _storage._moduleName != rhs_storage._moduleName {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._repeated != rhs_storage._repeated {return false}
        if _storage._repeatedFrequency != rhs_storage._repeatedFrequency {return false}
        if _storage._repeatedTotal != rhs_storage._repeatedTotal {return false}
        if _storage._batchCounter != rhs_storage._batchCounter {return false}
        if _storage._batchRequestCount != rhs_storage._batchRequestCount {return false}
        if _storage._batchResponseCount != rhs_storage._batchResponseCount {return false}
        if _storage._batchResponseThreshold != rhs_storage._batchResponseThreshold {return false}
        if _storage._responseThreshold != rhs_storage._responseThreshold {return false}
        if _storage._batchState != rhs_storage._batchState {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "service_name"),
    3: .same(proto: "provider"),
    4: .same(proto: "consumer"),
    5: .same(proto: "input"),
    6: .standard(proto: "service_fee"),
    7: .standard(proto: "request_height"),
    8: .standard(proto: "expiration_height"),
    9: .standard(proto: "request_context_id"),
    10: .standard(proto: "request_context_batch_counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.serviceName)
      case 3: try decoder.decodeSingularStringField(value: &self.provider)
      case 4: try decoder.decodeSingularStringField(value: &self.consumer)
      case 5: try decoder.decodeSingularStringField(value: &self.input)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.serviceFee)
      case 7: try decoder.decodeSingularInt64Field(value: &self.requestHeight)
      case 8: try decoder.decodeSingularInt64Field(value: &self.expirationHeight)
      case 9: try decoder.decodeSingularStringField(value: &self.requestContextID)
      case 10: try decoder.decodeSingularUInt64Field(value: &self.requestContextBatchCounter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 2)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 3)
    }
    if !self.consumer.isEmpty {
      try visitor.visitSingularStringField(value: self.consumer, fieldNumber: 4)
    }
    if !self.input.isEmpty {
      try visitor.visitSingularStringField(value: self.input, fieldNumber: 5)
    }
    if !self.serviceFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceFee, fieldNumber: 6)
    }
    if self.requestHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.requestHeight, fieldNumber: 7)
    }
    if self.expirationHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationHeight, fieldNumber: 8)
    }
    if !self.requestContextID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestContextID, fieldNumber: 9)
    }
    if self.requestContextBatchCounter != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestContextBatchCounter, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_Request, rhs: Irismod_Service_Request) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.consumer != rhs.consumer {return false}
    if lhs.input != rhs.input {return false}
    if lhs.serviceFee != rhs.serviceFee {return false}
    if lhs.requestHeight != rhs.requestHeight {return false}
    if lhs.expirationHeight != rhs.expirationHeight {return false}
    if lhs.requestContextID != rhs.requestContextID {return false}
    if lhs.requestContextBatchCounter != rhs.requestContextBatchCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_CompactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompactRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_context_id"),
    2: .standard(proto: "request_context_batch_counter"),
    3: .same(proto: "provider"),
    4: .standard(proto: "service_fee"),
    5: .standard(proto: "request_height"),
    6: .standard(proto: "expiration_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.requestContextID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.requestContextBatchCounter)
      case 3: try decoder.decodeSingularStringField(value: &self.provider)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.serviceFee)
      case 5: try decoder.decodeSingularInt64Field(value: &self.requestHeight)
      case 6: try decoder.decodeSingularInt64Field(value: &self.expirationHeight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestContextID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestContextID, fieldNumber: 1)
    }
    if self.requestContextBatchCounter != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestContextBatchCounter, fieldNumber: 2)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 3)
    }
    if !self.serviceFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceFee, fieldNumber: 4)
    }
    if self.requestHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.requestHeight, fieldNumber: 5)
    }
    if self.expirationHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationHeight, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_CompactRequest, rhs: Irismod_Service_CompactRequest) -> Bool {
    if lhs.requestContextID != rhs.requestContextID {return false}
    if lhs.requestContextBatchCounter != rhs.requestContextBatchCounter {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.serviceFee != rhs.serviceFee {return false}
    if lhs.requestHeight != rhs.requestHeight {return false}
    if lhs.expirationHeight != rhs.expirationHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "consumer"),
    3: .same(proto: "result"),
    4: .same(proto: "output"),
    5: .standard(proto: "request_context_id"),
    6: .standard(proto: "request_context_batch_counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.provider)
      case 2: try decoder.decodeSingularStringField(value: &self.consumer)
      case 3: try decoder.decodeSingularStringField(value: &self.result)
      case 4: try decoder.decodeSingularStringField(value: &self.output)
      case 5: try decoder.decodeSingularStringField(value: &self.requestContextID)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.requestContextBatchCounter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 1)
    }
    if !self.consumer.isEmpty {
      try visitor.visitSingularStringField(value: self.consumer, fieldNumber: 2)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 3)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularStringField(value: self.output, fieldNumber: 4)
    }
    if !self.requestContextID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestContextID, fieldNumber: 5)
    }
    if self.requestContextBatchCounter != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestContextBatchCounter, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_Response, rhs: Irismod_Service_Response) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.consumer != rhs.consumer {return false}
    if lhs.result != rhs.result {return false}
    if lhs.output != rhs.output {return false}
    if lhs.requestContextID != rhs.requestContextID {return false}
    if lhs.requestContextBatchCounter != rhs.requestContextBatchCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_Pricing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pricing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "price"),
    2: .standard(proto: "promotions_by_time"),
    3: .standard(proto: "promotions_by_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.promotionsByTime)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.promotionsByVolume)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.price)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.promotionsByTime.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.promotionsByTime, fieldNumber: 2)
    }
    if !self.promotionsByVolume.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.promotionsByVolume, fieldNumber: 3)
    }
    if !self.price.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.price, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_Pricing, rhs: Irismod_Service_Pricing) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.promotionsByTime != rhs.promotionsByTime {return false}
    if lhs.promotionsByVolume != rhs.promotionsByVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_PromotionByTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromotionByTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "discount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._startTime)
      case 2: try decoder.decodeSingularMessageField(value: &self._endTime)
      case 3: try decoder.decodeSingularStringField(value: &self.discount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.discount.isEmpty {
      try visitor.visitSingularStringField(value: self.discount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_PromotionByTime, rhs: Irismod_Service_PromotionByTime) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.discount != rhs.discount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_PromotionByVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromotionByVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volume"),
    2: .same(proto: "discount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.volume)
      case 2: try decoder.decodeSingularStringField(value: &self.discount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.volume != 0 {
      try visitor.visitSingularUInt64Field(value: self.volume, fieldNumber: 1)
    }
    if !self.discount.isEmpty {
      try visitor.visitSingularStringField(value: self.discount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_PromotionByVolume, rhs: Irismod_Service_PromotionByVolume) -> Bool {
    if lhs.volume != rhs.volume {return false}
    if lhs.discount != rhs.discount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Irismod_Service_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_request_timeout"),
    2: .standard(proto: "min_deposit_multiple"),
    3: .standard(proto: "min_deposit"),
    4: .standard(proto: "service_fee_tax"),
    5: .standard(proto: "slash_fraction"),
    6: .standard(proto: "complaint_retrospect"),
    7: .standard(proto: "arbitration_time_limit"),
    8: .standard(proto: "tx_size_limit"),
    9: .standard(proto: "base_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.maxRequestTimeout)
      case 2: try decoder.decodeSingularInt64Field(value: &self.minDepositMultiple)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.minDeposit)
      case 4: try decoder.decodeSingularStringField(value: &self.serviceFeeTax)
      case 5: try decoder.decodeSingularStringField(value: &self.slashFraction)
      case 6: try decoder.decodeSingularMessageField(value: &self._complaintRetrospect)
      case 7: try decoder.decodeSingularMessageField(value: &self._arbitrationTimeLimit)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.txSizeLimit)
      case 9: try decoder.decodeSingularStringField(value: &self.baseDenom)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxRequestTimeout != 0 {
      try visitor.visitSingularInt64Field(value: self.maxRequestTimeout, fieldNumber: 1)
    }
    if self.minDepositMultiple != 0 {
      try visitor.visitSingularInt64Field(value: self.minDepositMultiple, fieldNumber: 2)
    }
    if !self.minDeposit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.minDeposit, fieldNumber: 3)
    }
    if !self.serviceFeeTax.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceFeeTax, fieldNumber: 4)
    }
    if !self.slashFraction.isEmpty {
      try visitor.visitSingularStringField(value: self.slashFraction, fieldNumber: 5)
    }
    if let v = self._complaintRetrospect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._arbitrationTimeLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.txSizeLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.txSizeLimit, fieldNumber: 8)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Irismod_Service_Params, rhs: Irismod_Service_Params) -> Bool {
    if lhs.maxRequestTimeout != rhs.maxRequestTimeout {return false}
    if lhs.minDepositMultiple != rhs.minDepositMultiple {return false}
    if lhs.minDeposit != rhs.minDeposit {return false}
    if lhs.serviceFeeTax != rhs.serviceFeeTax {return false}
    if lhs.slashFraction != rhs.slashFraction {return false}
    if lhs._complaintRetrospect != rhs._complaintRetrospect {return false}
    if lhs._arbitrationTimeLimit != rhs._arbitrationTimeLimit {return false}
    if lhs.txSizeLimit != rhs.txSizeLimit {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
