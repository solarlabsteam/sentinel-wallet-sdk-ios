// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/ics23/v1/proofs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Cosmos_Ics23_V1_HashOp: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// NO_HASH is the default if no data passed. Note this is an illegal argument some places.
  case noHash // = 0
  case sha256 // = 1
  case sha512 // = 2
  case keccak // = 3
  case ripemd160 // = 4

  /// ripemd160(sha256(x))
  case bitcoin // = 5
  case sha512256 // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .noHash
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noHash
    case 1: self = .sha256
    case 2: self = .sha512
    case 3: self = .keccak
    case 4: self = .ripemd160
    case 5: self = .bitcoin
    case 6: self = .sha512256
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noHash: return 0
    case .sha256: return 1
    case .sha512: return 2
    case .keccak: return 3
    case .ripemd160: return 4
    case .bitcoin: return 5
    case .sha512256: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cosmos_Ics23_V1_HashOp: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Ics23_V1_HashOp] = [
    .noHash,
    .sha256,
    .sha512,
    .keccak,
    .ripemd160,
    .bitcoin,
    .sha512256,
  ]
}

#endif  // swift(>=4.2)

///*
///LengthOp defines how to process the key and value of the LeafOp
///to include length information. After encoding the length with the given
///algorithm, the length will be prepended to the key and value bytes.
///(Each one with it's own encoded length)
enum Cosmos_Ics23_V1_LengthOp: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// NO_PREFIX don't include any length info
  case noPrefix // = 0

  /// VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
  case varProto // = 1

  /// VAR_RLP uses rlp int encoding of the length
  case varRlp // = 2

  /// FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
  case fixed32Big // = 3

  /// FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
  case fixed32Little // = 4

  /// FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
  case fixed64Big // = 5

  /// FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
  case fixed64Little // = 6

  /// REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
  case require32Bytes // = 7

  /// REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
  case require64Bytes // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .noPrefix
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPrefix
    case 1: self = .varProto
    case 2: self = .varRlp
    case 3: self = .fixed32Big
    case 4: self = .fixed32Little
    case 5: self = .fixed64Big
    case 6: self = .fixed64Little
    case 7: self = .require32Bytes
    case 8: self = .require64Bytes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPrefix: return 0
    case .varProto: return 1
    case .varRlp: return 2
    case .fixed32Big: return 3
    case .fixed32Little: return 4
    case .fixed64Big: return 5
    case .fixed64Little: return 6
    case .require32Bytes: return 7
    case .require64Bytes: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cosmos_Ics23_V1_LengthOp: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Ics23_V1_LengthOp] = [
    .noPrefix,
    .varProto,
    .varRlp,
    .fixed32Big,
    .fixed32Little,
    .fixed64Big,
    .fixed64Little,
    .require32Bytes,
    .require64Bytes,
  ]
}

#endif  // swift(>=4.2)

///*
///ExistenceProof takes a key and a value and a set of steps to perform on it.
///The result of peforming all these steps will provide a "root hash", which can
///be compared to the value in a header.
///
///Since it is computationally infeasible to produce a hash collission for any of the used
///cryptographic hash functions, if someone can provide a series of operations to transform
///a given key and value into a root hash that matches some trusted root, these key and values
///must be in the referenced merkle tree.
///
///The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
///which should be controlled by a spec. Eg. with lengthOp as NONE,
///prefix = FOO, key = BAR, value = CHOICE
///and
///prefix = F, key = OOBAR, value = CHOICE
///would produce the same value.
///
///With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
///in the ProofSpec is valuable to prevent this mutability. And why all trees should
///length-prefix the data before hashing it.
struct Cosmos_Ics23_V1_ExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Data = Data()

  var value: Data = Data()

  var leaf: Cosmos_Ics23_V1_LeafOp {
    get {return _leaf ?? Cosmos_Ics23_V1_LeafOp()}
    set {_leaf = newValue}
  }
  /// Returns true if `leaf` has been explicitly set.
  var hasLeaf: Bool {return self._leaf != nil}
  /// Clears the value of `leaf`. Subsequent reads from it will return its default value.
  mutating func clearLeaf() {self._leaf = nil}

  var path: [Cosmos_Ics23_V1_InnerOp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leaf: Cosmos_Ics23_V1_LeafOp? = nil
}

///
///NonExistenceProof takes a proof of two neighbors, one left of the desired key,
///one right of the desired key. If both proofs are valid AND they are neighbors,
///then there is no valid proof for the given key.
struct Cosmos_Ics23_V1_NonExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: remove this as unnecessary??? we prove a range
  var key: Data {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var left: Cosmos_Ics23_V1_ExistenceProof {
    get {return _storage._left ?? Cosmos_Ics23_V1_ExistenceProof()}
    set {_uniqueStorage()._left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return _storage._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {_uniqueStorage()._left = nil}

  var right: Cosmos_Ics23_V1_ExistenceProof {
    get {return _storage._right ?? Cosmos_Ics23_V1_ExistenceProof()}
    set {_uniqueStorage()._right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return _storage._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {_uniqueStorage()._right = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
///CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
struct Cosmos_Ics23_V1_CommitmentProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Cosmos_Ics23_V1_CommitmentProof.OneOf_Proof? = nil

  var exist: Cosmos_Ics23_V1_ExistenceProof {
    get {
      if case .exist(let v)? = proof {return v}
      return Cosmos_Ics23_V1_ExistenceProof()
    }
    set {proof = .exist(newValue)}
  }

  var nonexist: Cosmos_Ics23_V1_NonExistenceProof {
    get {
      if case .nonexist(let v)? = proof {return v}
      return Cosmos_Ics23_V1_NonExistenceProof()
    }
    set {proof = .nonexist(newValue)}
  }

  var batch: Cosmos_Ics23_V1_BatchProof {
    get {
      if case .batch(let v)? = proof {return v}
      return Cosmos_Ics23_V1_BatchProof()
    }
    set {proof = .batch(newValue)}
  }

  var compressed: Cosmos_Ics23_V1_CompressedBatchProof {
    get {
      if case .compressed(let v)? = proof {return v}
      return Cosmos_Ics23_V1_CompressedBatchProof()
    }
    set {proof = .compressed(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Proof: Equatable {
    case exist(Cosmos_Ics23_V1_ExistenceProof)
    case nonexist(Cosmos_Ics23_V1_NonExistenceProof)
    case batch(Cosmos_Ics23_V1_BatchProof)
    case compressed(Cosmos_Ics23_V1_CompressedBatchProof)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Ics23_V1_CommitmentProof.OneOf_Proof, rhs: Cosmos_Ics23_V1_CommitmentProof.OneOf_Proof) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exist, .exist): return {
        guard case .exist(let l) = lhs, case .exist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonexist, .nonexist): return {
        guard case .nonexist(let l) = lhs, case .nonexist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batch, .batch): return {
        guard case .batch(let l) = lhs, case .batch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compressed, .compressed): return {
        guard case .compressed(let l) = lhs, case .compressed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///*
///LeafOp represents the raw key-value data we wish to prove, and
///must be flexible to represent the internal transformation from
///the original key-value pairs into the basis hash, for many existing
///merkle trees.
///
///key and value are passed in. So that the signature of this operation is:
///leafOp(key, value) -> output
///
///To process this, first prehash the keys and values if needed (ANY means no hash in this case):
///hkey = prehashKey(key)
///hvalue = prehashValue(value)
///
///Then combine the bytes, and hash it
///output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
struct Cosmos_Ics23_V1_LeafOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Cosmos_Ics23_V1_HashOp = .noHash

  var prehashKey: Cosmos_Ics23_V1_HashOp = .noHash

  var prehashValue: Cosmos_Ics23_V1_HashOp = .noHash

  var length: Cosmos_Ics23_V1_LengthOp = .noPrefix

  /// prefix is a fixed bytes that may optionally be included at the beginning to differentiate
  /// a leaf node from an inner node.
  var prefix: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///InnerOp represents a merkle-proof step that is not a leaf.
///It represents concatenating two children and hashing them to provide the next result.
///
///The result of the previous step is passed in, so the signature of this op is:
///innerOp(child) -> output
///
///The result of applying InnerOp should be:
///output = op.hash(op.prefix || child || op.suffix)
///
///where the || operator is concatenation of binary data,
///and child is the result of hashing all the tree below this step.
///
///Any special data, like prepending child with the length, or prepending the entire operation with
///some value to differentiate from leaf nodes, should be included in prefix and suffix.
///If either of prefix or suffix is empty, we just treat it as an empty string
struct Cosmos_Ics23_V1_InnerOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Cosmos_Ics23_V1_HashOp = .noHash

  var prefix: Data = Data()

  var suffix: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///ProofSpec defines what the expected parameters are for a given proof type.
///This can be stored in the client and used to validate any incoming proofs.
///
///verify(ProofSpec, Proof) -> Proof | Error
///
///As demonstrated in tests, if we don't fix the algorithm used to calculate the
///LeafHash for a given tree, there are many possible key-value pairs that can
///generate a given hash (by interpretting the preimage differently).
///We need this for proper security, requires client knows a priori what
///tree format server uses. But not in code, rather a configuration object.
struct Cosmos_Ics23_V1_ProofSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// any field in the ExistenceProof must be the same as in this spec.
  /// except Prefix, which is just the first bytes of prefix (spec can be longer)
  var leafSpec: Cosmos_Ics23_V1_LeafOp {
    get {return _leafSpec ?? Cosmos_Ics23_V1_LeafOp()}
    set {_leafSpec = newValue}
  }
  /// Returns true if `leafSpec` has been explicitly set.
  var hasLeafSpec: Bool {return self._leafSpec != nil}
  /// Clears the value of `leafSpec`. Subsequent reads from it will return its default value.
  mutating func clearLeafSpec() {self._leafSpec = nil}

  var innerSpec: Cosmos_Ics23_V1_InnerSpec {
    get {return _innerSpec ?? Cosmos_Ics23_V1_InnerSpec()}
    set {_innerSpec = newValue}
  }
  /// Returns true if `innerSpec` has been explicitly set.
  var hasInnerSpec: Bool {return self._innerSpec != nil}
  /// Clears the value of `innerSpec`. Subsequent reads from it will return its default value.
  mutating func clearInnerSpec() {self._innerSpec = nil}

  /// max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
  var maxDepth: Int32 = 0

  /// min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
  var minDepth: Int32 = 0

  /// prehash_key_before_comparison is a flag that indicates whether to use the
  /// prehash_key specified by LeafOp to compare lexical ordering of keys for
  /// non-existence proofs.
  var prehashKeyBeforeComparison: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leafSpec: Cosmos_Ics23_V1_LeafOp? = nil
  fileprivate var _innerSpec: Cosmos_Ics23_V1_InnerSpec? = nil
}

///
///InnerSpec contains all store-specific structure info to determine if two proofs from a
///given store are neighbors.
///
///This enables:
///
///isLeftMost(spec: InnerSpec, op: InnerOp)
///isRightMost(spec: InnerSpec, op: InnerOp)
///isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
struct Cosmos_Ics23_V1_InnerSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Child order is the ordering of the children node, must count from 0
  /// iavl tree is [0, 1] (left then right)
  /// merk is [0, 2, 1] (left, right, here)
  var childOrder: [Int32] = []

  var childSize: Int32 = 0

  var minPrefixLength: Int32 = 0

  var maxPrefixLength: Int32 = 0

  /// empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
  var emptyChild: Data = Data()

  /// hash is the algorithm that must be used for each InnerOp
  var hash: Cosmos_Ics23_V1_HashOp = .noHash

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///BatchProof is a group of multiple proof types than can be compressed
struct Cosmos_Ics23_V1_BatchProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Cosmos_Ics23_V1_BatchEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Use BatchEntry not CommitmentProof, to avoid recursion
struct Cosmos_Ics23_V1_BatchEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Cosmos_Ics23_V1_BatchEntry.OneOf_Proof? = nil

  var exist: Cosmos_Ics23_V1_ExistenceProof {
    get {
      if case .exist(let v)? = proof {return v}
      return Cosmos_Ics23_V1_ExistenceProof()
    }
    set {proof = .exist(newValue)}
  }

  var nonexist: Cosmos_Ics23_V1_NonExistenceProof {
    get {
      if case .nonexist(let v)? = proof {return v}
      return Cosmos_Ics23_V1_NonExistenceProof()
    }
    set {proof = .nonexist(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Proof: Equatable {
    case exist(Cosmos_Ics23_V1_ExistenceProof)
    case nonexist(Cosmos_Ics23_V1_NonExistenceProof)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Ics23_V1_BatchEntry.OneOf_Proof, rhs: Cosmos_Ics23_V1_BatchEntry.OneOf_Proof) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exist, .exist): return {
        guard case .exist(let l) = lhs, case .exist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonexist, .nonexist): return {
        guard case .nonexist(let l) = lhs, case .nonexist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Cosmos_Ics23_V1_CompressedBatchProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Cosmos_Ics23_V1_CompressedBatchEntry] = []

  var lookupInners: [Cosmos_Ics23_V1_InnerOp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Use BatchEntry not CommitmentProof, to avoid recursion
struct Cosmos_Ics23_V1_CompressedBatchEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Cosmos_Ics23_V1_CompressedBatchEntry.OneOf_Proof? = nil

  var exist: Cosmos_Ics23_V1_CompressedExistenceProof {
    get {
      if case .exist(let v)? = proof {return v}
      return Cosmos_Ics23_V1_CompressedExistenceProof()
    }
    set {proof = .exist(newValue)}
  }

  var nonexist: Cosmos_Ics23_V1_CompressedNonExistenceProof {
    get {
      if case .nonexist(let v)? = proof {return v}
      return Cosmos_Ics23_V1_CompressedNonExistenceProof()
    }
    set {proof = .nonexist(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Proof: Equatable {
    case exist(Cosmos_Ics23_V1_CompressedExistenceProof)
    case nonexist(Cosmos_Ics23_V1_CompressedNonExistenceProof)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Ics23_V1_CompressedBatchEntry.OneOf_Proof, rhs: Cosmos_Ics23_V1_CompressedBatchEntry.OneOf_Proof) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exist, .exist): return {
        guard case .exist(let l) = lhs, case .exist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonexist, .nonexist): return {
        guard case .nonexist(let l) = lhs, case .nonexist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Cosmos_Ics23_V1_CompressedExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Data = Data()

  var value: Data = Data()

  var leaf: Cosmos_Ics23_V1_LeafOp {
    get {return _leaf ?? Cosmos_Ics23_V1_LeafOp()}
    set {_leaf = newValue}
  }
  /// Returns true if `leaf` has been explicitly set.
  var hasLeaf: Bool {return self._leaf != nil}
  /// Clears the value of `leaf`. Subsequent reads from it will return its default value.
  mutating func clearLeaf() {self._leaf = nil}

  /// these are indexes into the lookup_inners table in CompressedBatchProof
  var path: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leaf: Cosmos_Ics23_V1_LeafOp? = nil
}

struct Cosmos_Ics23_V1_CompressedNonExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: remove this as unnecessary??? we prove a range
  var key: Data {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var left: Cosmos_Ics23_V1_CompressedExistenceProof {
    get {return _storage._left ?? Cosmos_Ics23_V1_CompressedExistenceProof()}
    set {_uniqueStorage()._left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return _storage._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {_uniqueStorage()._left = nil}

  var right: Cosmos_Ics23_V1_CompressedExistenceProof {
    get {return _storage._right ?? Cosmos_Ics23_V1_CompressedExistenceProof()}
    set {_uniqueStorage()._right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return _storage._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {_uniqueStorage()._right = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cosmos_Ics23_V1_HashOp: @unchecked Sendable {}
extension Cosmos_Ics23_V1_LengthOp: @unchecked Sendable {}
extension Cosmos_Ics23_V1_ExistenceProof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_NonExistenceProof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CommitmentProof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CommitmentProof.OneOf_Proof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_LeafOp: @unchecked Sendable {}
extension Cosmos_Ics23_V1_InnerOp: @unchecked Sendable {}
extension Cosmos_Ics23_V1_ProofSpec: @unchecked Sendable {}
extension Cosmos_Ics23_V1_InnerSpec: @unchecked Sendable {}
extension Cosmos_Ics23_V1_BatchProof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_BatchEntry: @unchecked Sendable {}
extension Cosmos_Ics23_V1_BatchEntry.OneOf_Proof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CompressedBatchProof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CompressedBatchEntry: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CompressedBatchEntry.OneOf_Proof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CompressedExistenceProof: @unchecked Sendable {}
extension Cosmos_Ics23_V1_CompressedNonExistenceProof: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.ics23.v1"

extension Cosmos_Ics23_V1_HashOp: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_HASH"),
    1: .same(proto: "SHA256"),
    2: .same(proto: "SHA512"),
    3: .same(proto: "KECCAK"),
    4: .same(proto: "RIPEMD160"),
    5: .same(proto: "BITCOIN"),
    6: .same(proto: "SHA512_256"),
  ]
}

extension Cosmos_Ics23_V1_LengthOp: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PREFIX"),
    1: .same(proto: "VAR_PROTO"),
    2: .same(proto: "VAR_RLP"),
    3: .same(proto: "FIXED32_BIG"),
    4: .same(proto: "FIXED32_LITTLE"),
    5: .same(proto: "FIXED64_BIG"),
    6: .same(proto: "FIXED64_LITTLE"),
    7: .same(proto: "REQUIRE_32_BYTES"),
    8: .same(proto: "REQUIRE_64_BYTES"),
  ]
}

extension Cosmos_Ics23_V1_ExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "leaf"),
    4: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._leaf) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._leaf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_ExistenceProof, rhs: Cosmos_Ics23_V1_ExistenceProof) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._leaf != rhs._leaf {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_NonExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NonExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "left"),
    3: .same(proto: "right"),
  ]

  fileprivate class _StorageClass {
    var _key: Data = Data()
    var _left: Cosmos_Ics23_V1_ExistenceProof? = nil
    var _right: Cosmos_Ics23_V1_ExistenceProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _left = source._left
      _right = source._right
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._key.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._key, fieldNumber: 1)
      }
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_NonExistenceProof, rhs: Cosmos_Ics23_V1_NonExistenceProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_CommitmentProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitmentProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exist"),
    2: .same(proto: "nonexist"),
    3: .same(proto: "batch"),
    4: .same(proto: "compressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cosmos_Ics23_V1_ExistenceProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .exist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .exist(v)
        }
      }()
      case 2: try {
        var v: Cosmos_Ics23_V1_NonExistenceProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .nonexist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .nonexist(v)
        }
      }()
      case 3: try {
        var v: Cosmos_Ics23_V1_BatchProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .batch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .batch(v)
        }
      }()
      case 4: try {
        var v: Cosmos_Ics23_V1_CompressedBatchProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .compressed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .compressed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.proof {
    case .exist?: try {
      guard case .exist(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .nonexist?: try {
      guard case .nonexist(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .batch?: try {
      guard case .batch(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .compressed?: try {
      guard case .compressed(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_CommitmentProof, rhs: Cosmos_Ics23_V1_CommitmentProof) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_LeafOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeafOp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "prehash_key"),
    3: .standard(proto: "prehash_value"),
    4: .same(proto: "length"),
    5: .same(proto: "prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.prehashKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.prehashValue) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.length) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.prefix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hash != .noHash {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 1)
    }
    if self.prehashKey != .noHash {
      try visitor.visitSingularEnumField(value: self.prehashKey, fieldNumber: 2)
    }
    if self.prehashValue != .noHash {
      try visitor.visitSingularEnumField(value: self.prehashValue, fieldNumber: 3)
    }
    if self.length != .noPrefix {
      try visitor.visitSingularEnumField(value: self.length, fieldNumber: 4)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_LeafOp, rhs: Cosmos_Ics23_V1_LeafOp) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.prehashKey != rhs.prehashKey {return false}
    if lhs.prehashValue != rhs.prehashValue {return false}
    if lhs.length != rhs.length {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_InnerOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InnerOp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "prefix"),
    3: .same(proto: "suffix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.prefix) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.suffix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hash != .noHash {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 2)
    }
    if !self.suffix.isEmpty {
      try visitor.visitSingularBytesField(value: self.suffix, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_InnerOp, rhs: Cosmos_Ics23_V1_InnerOp) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.suffix != rhs.suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_ProofSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProofSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaf_spec"),
    2: .standard(proto: "inner_spec"),
    3: .standard(proto: "max_depth"),
    4: .standard(proto: "min_depth"),
    5: .standard(proto: "prehash_key_before_comparison"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._leafSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._innerSpec) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxDepth) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.minDepth) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.prehashKeyBeforeComparison) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._leafSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._innerSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maxDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDepth, fieldNumber: 3)
    }
    if self.minDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.minDepth, fieldNumber: 4)
    }
    if self.prehashKeyBeforeComparison != false {
      try visitor.visitSingularBoolField(value: self.prehashKeyBeforeComparison, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_ProofSpec, rhs: Cosmos_Ics23_V1_ProofSpec) -> Bool {
    if lhs._leafSpec != rhs._leafSpec {return false}
    if lhs._innerSpec != rhs._innerSpec {return false}
    if lhs.maxDepth != rhs.maxDepth {return false}
    if lhs.minDepth != rhs.minDepth {return false}
    if lhs.prehashKeyBeforeComparison != rhs.prehashKeyBeforeComparison {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_InnerSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InnerSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_order"),
    2: .standard(proto: "child_size"),
    3: .standard(proto: "min_prefix_length"),
    4: .standard(proto: "max_prefix_length"),
    5: .standard(proto: "empty_child"),
    6: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.childOrder) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.childSize) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minPrefixLength) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxPrefixLength) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.emptyChild) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.hash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.childOrder.isEmpty {
      try visitor.visitPackedInt32Field(value: self.childOrder, fieldNumber: 1)
    }
    if self.childSize != 0 {
      try visitor.visitSingularInt32Field(value: self.childSize, fieldNumber: 2)
    }
    if self.minPrefixLength != 0 {
      try visitor.visitSingularInt32Field(value: self.minPrefixLength, fieldNumber: 3)
    }
    if self.maxPrefixLength != 0 {
      try visitor.visitSingularInt32Field(value: self.maxPrefixLength, fieldNumber: 4)
    }
    if !self.emptyChild.isEmpty {
      try visitor.visitSingularBytesField(value: self.emptyChild, fieldNumber: 5)
    }
    if self.hash != .noHash {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_InnerSpec, rhs: Cosmos_Ics23_V1_InnerSpec) -> Bool {
    if lhs.childOrder != rhs.childOrder {return false}
    if lhs.childSize != rhs.childSize {return false}
    if lhs.minPrefixLength != rhs.minPrefixLength {return false}
    if lhs.maxPrefixLength != rhs.maxPrefixLength {return false}
    if lhs.emptyChild != rhs.emptyChild {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_BatchProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_BatchProof, rhs: Cosmos_Ics23_V1_BatchProof) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_BatchEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exist"),
    2: .same(proto: "nonexist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cosmos_Ics23_V1_ExistenceProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .exist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .exist(v)
        }
      }()
      case 2: try {
        var v: Cosmos_Ics23_V1_NonExistenceProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .nonexist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .nonexist(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.proof {
    case .exist?: try {
      guard case .exist(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .nonexist?: try {
      guard case .nonexist(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_BatchEntry, rhs: Cosmos_Ics23_V1_BatchEntry) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_CompressedBatchProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedBatchProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "lookup_inners"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lookupInners) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.lookupInners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lookupInners, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_CompressedBatchProof, rhs: Cosmos_Ics23_V1_CompressedBatchProof) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.lookupInners != rhs.lookupInners {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_CompressedBatchEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedBatchEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exist"),
    2: .same(proto: "nonexist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cosmos_Ics23_V1_CompressedExistenceProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .exist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .exist(v)
        }
      }()
      case 2: try {
        var v: Cosmos_Ics23_V1_CompressedNonExistenceProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .nonexist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .nonexist(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.proof {
    case .exist?: try {
      guard case .exist(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .nonexist?: try {
      guard case .nonexist(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_CompressedBatchEntry, rhs: Cosmos_Ics23_V1_CompressedBatchEntry) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_CompressedExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "leaf"),
    4: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._leaf) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._leaf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.path.isEmpty {
      try visitor.visitPackedInt32Field(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_CompressedExistenceProof, rhs: Cosmos_Ics23_V1_CompressedExistenceProof) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._leaf != rhs._leaf {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Ics23_V1_CompressedNonExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedNonExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "left"),
    3: .same(proto: "right"),
  ]

  fileprivate class _StorageClass {
    var _key: Data = Data()
    var _left: Cosmos_Ics23_V1_CompressedExistenceProof? = nil
    var _right: Cosmos_Ics23_V1_CompressedExistenceProof? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _left = source._left
      _right = source._right
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._key.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._key, fieldNumber: 1)
      }
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Ics23_V1_CompressedNonExistenceProof, rhs: Cosmos_Ics23_V1_CompressedNonExistenceProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
