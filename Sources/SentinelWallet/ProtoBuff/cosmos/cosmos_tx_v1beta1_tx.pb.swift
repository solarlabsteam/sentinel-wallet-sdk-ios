// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/tx/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tx is the standard type used for broadcasting transactions.
struct Cosmos_Tx_V1beta1_Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body is the processable content of the transaction
  var body: Cosmos_Tx_V1beta1_TxBody {
    get {return _body ?? Cosmos_Tx_V1beta1_TxBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  /// auth_info is the authorization related content of the transaction,
  /// specifically signers, signer modes and fee
  var authInfo: Cosmos_Tx_V1beta1_AuthInfo {
    get {return _authInfo ?? Cosmos_Tx_V1beta1_AuthInfo()}
    set {_authInfo = newValue}
  }
  /// Returns true if `authInfo` has been explicitly set.
  var hasAuthInfo: Bool {return self._authInfo != nil}
  /// Clears the value of `authInfo`. Subsequent reads from it will return its default value.
  mutating func clearAuthInfo() {self._authInfo = nil}

  /// signatures is a list of signatures that matches the length and order of
  /// AuthInfo's signer_infos to allow connecting signature meta information like
  /// public key and signing mode by position.
  var signatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: Cosmos_Tx_V1beta1_TxBody? = nil
  fileprivate var _authInfo: Cosmos_Tx_V1beta1_AuthInfo? = nil
}

/// TxRaw is a variant of Tx that pins the signer's exact binary representation
/// of body and auth_info. This is used for signing, broadcasting and
/// verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
/// the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
/// as the transaction ID.
struct Cosmos_Tx_V1beta1_TxRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is a protobuf serialization of a TxBody that matches the
  /// representation in SignDoc.
  var bodyBytes: Data = SwiftProtobuf.Internal.emptyData

  /// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  /// representation in SignDoc.
  var authInfoBytes: Data = SwiftProtobuf.Internal.emptyData

  /// signatures is a list of signatures that matches the length and order of
  /// AuthInfo's signer_infos to allow connecting signature meta information like
  /// public key and signing mode by position.
  var signatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
struct Cosmos_Tx_V1beta1_SignDoc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is protobuf serialization of a TxBody that matches the
  /// representation in TxRaw.
  var bodyBytes: Data = SwiftProtobuf.Internal.emptyData

  /// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  /// representation in TxRaw.
  var authInfoBytes: Data = SwiftProtobuf.Internal.emptyData

  /// chain_id is the unique identifier of the chain this transaction targets.
  /// It prevents signed transactions from being used on another chain by an
  /// attacker
  var chainID: String = String()

  /// account_number is the account number of the account in state
  var accountNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TxBody is the body of a transaction that all signers sign over.
struct Cosmos_Tx_V1beta1_TxBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// messages is a list of messages to be executed. The required signers of
  /// those messages define the number and order of elements in AuthInfo's
  /// signer_infos and Tx's signatures. Each required signer address is added to
  /// the list only the first time it occurs.
  /// By convention, the first required signer (usually from the first message)
  /// is referred to as the primary signer and pays the fee for the whole
  /// transaction.
  var messages: [Google_Protobuf2_Any] = []

  /// memo is any arbitrary memo to be added to the transaction
  var memo: String = String()

  /// timeout is the block height after which this transaction will not
  /// be processed by the chain
  var timeoutHeight: UInt64 = 0

  /// extension_options are arbitrary options that can be added by chains
  /// when the default options are not sufficient. If any of these are present
  /// and can't be handled, the transaction will be rejected
  var extensionOptions: [Google_Protobuf2_Any] = []

  /// extension_options are arbitrary options that can be added by chains
  /// when the default options are not sufficient. If any of these are present
  /// and can't be handled, they will be ignored
  var nonCriticalExtensionOptions: [Google_Protobuf2_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuthInfo describes the fee and signer modes that are used to sign a
/// transaction.
struct Cosmos_Tx_V1beta1_AuthInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signer_infos defines the signing modes for the required signers. The number
  /// and order of elements must match the required signers from TxBody's
  /// messages. The first element is the primary signer and the one which pays
  /// the fee.
  var signerInfos: [Cosmos_Tx_V1beta1_SignerInfo] = []

  /// Fee is the fee and gas limit for the transaction. The first signer is the
  /// primary signer and the one which pays the fee. The fee can be calculated
  /// based on the cost of evaluating the body and doing signature verification
  /// of the signers. This can be estimated via simulation.
  var fee: Cosmos_Tx_V1beta1_Fee {
    get {return _fee ?? Cosmos_Tx_V1beta1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fee: Cosmos_Tx_V1beta1_Fee? = nil
}

/// SignerInfo describes the public key and signing mode of a single top-level
/// signer.
struct Cosmos_Tx_V1beta1_SignerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// public_key is the public key of the signer. It is optional for accounts
  /// that already exist in state. If unset, the verifier can use the required \
  /// signer address for this position and lookup the public key.
  var publicKey: Google_Protobuf2_Any {
    get {return _publicKey ?? Google_Protobuf2_Any()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// mode_info describes the signing mode of the signer and is a nested
  /// structure to support nested multisig pubkey's
  var modeInfo: Cosmos_Tx_V1beta1_ModeInfo {
    get {return _modeInfo ?? Cosmos_Tx_V1beta1_ModeInfo()}
    set {_modeInfo = newValue}
  }
  /// Returns true if `modeInfo` has been explicitly set.
  var hasModeInfo: Bool {return self._modeInfo != nil}
  /// Clears the value of `modeInfo`. Subsequent reads from it will return its default value.
  mutating func clearModeInfo() {self._modeInfo = nil}

  /// sequence is the sequence of the account, which describes the
  /// number of committed transactions signed by a given address. It is used to
  /// prevent replay attacks.
  var sequence: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Google_Protobuf2_Any? = nil
  fileprivate var _modeInfo: Cosmos_Tx_V1beta1_ModeInfo? = nil
}

/// ModeInfo describes the signing mode of a single or nested multisig signer.
struct Cosmos_Tx_V1beta1_ModeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sum is the oneof that specifies whether this represents a single or nested
  /// multisig signer
  var sum: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum? = nil

  /// single represents a single signer
  var single: Cosmos_Tx_V1beta1_ModeInfo.Single {
    get {
      if case .single(let v)? = sum {return v}
      return Cosmos_Tx_V1beta1_ModeInfo.Single()
    }
    set {sum = .single(newValue)}
  }

  /// multi represents a nested multisig signer
  var multi: Cosmos_Tx_V1beta1_ModeInfo.Multi {
    get {
      if case .multi(let v)? = sum {return v}
      return Cosmos_Tx_V1beta1_ModeInfo.Multi()
    }
    set {sum = .multi(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// sum is the oneof that specifies whether this represents a single or nested
  /// multisig signer
  enum OneOf_Sum: Equatable {
    /// single represents a single signer
    case single(Cosmos_Tx_V1beta1_ModeInfo.Single)
    /// multi represents a nested multisig signer
    case multi(Cosmos_Tx_V1beta1_ModeInfo.Multi)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum, rhs: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum) -> Bool {
      switch (lhs, rhs) {
      case (.single(let l), .single(let r)): return l == r
      case (.multi(let l), .multi(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Single is the mode info for a single signer. It is structured as a message
  /// to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
  /// future
  struct Single {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// mode is the signing mode of the single signer
    var mode: Cosmos_Tx_Signing_V1beta1_SignMode = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Multi is the mode info for a multisig public key
  struct Multi {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// bitarray specifies which keys within the multisig are signing
    var bitarray: Cosmos_Crypto_Multisig_V1beta1_CompactBitArray {
      get {return _bitarray ?? Cosmos_Crypto_Multisig_V1beta1_CompactBitArray()}
      set {_bitarray = newValue}
    }
    /// Returns true if `bitarray` has been explicitly set.
    var hasBitarray: Bool {return self._bitarray != nil}
    /// Clears the value of `bitarray`. Subsequent reads from it will return its default value.
    mutating func clearBitarray() {self._bitarray = nil}

    /// mode_infos is the corresponding modes of the signers of the multisig
    /// which could include nested multisig public keys
    var modeInfos: [Cosmos_Tx_V1beta1_ModeInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bitarray: Cosmos_Crypto_Multisig_V1beta1_CompactBitArray? = nil
  }

  init() {}
}

/// Fee includes the amount of coins paid in fees and the maximum
/// gas to be used by the transaction. The ratio yields an effective "gasprice",
/// which must be above some miminum to be accepted into the mempool.
struct Cosmos_Tx_V1beta1_Fee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount is the amount of coins to be paid as a fee
  var amount: [Cosmos_Base_V1beta1_Coin] = []

  /// gas_limit is the maximum gas that can be used in transaction processing
  /// before an out of gas error occurs
  var gasLimit: UInt64 = 0

  /// if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
  /// the payer must be a tx signer (and thus have signed this field in AuthInfo).
  /// setting this field does *not* change the ordering of required signers for the transaction.
  var payer: String = String()

  /// if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
  /// to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
  /// not support fee grants, this will fail
  var granter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.tx.v1beta1"

extension Cosmos_Tx_V1beta1_Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_info"),
    3: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._body)
      case 2: try decoder.decodeSingularMessageField(value: &self._authInfo)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.signatures)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._authInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Tx, rhs: Cosmos_Tx_V1beta1_Tx) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs._authInfo != rhs._authInfo {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_TxRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "auth_info_bytes"),
    3: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.bodyBytes)
      case 2: try decoder.decodeSingularBytesField(value: &self.authInfoBytes)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.signatures)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if !self.authInfoBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.authInfoBytes, fieldNumber: 2)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_TxRaw, rhs: Cosmos_Tx_V1beta1_TxRaw) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs.authInfoBytes != rhs.authInfoBytes {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignDoc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignDoc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "auth_info_bytes"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "account_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.bodyBytes)
      case 2: try decoder.decodeSingularBytesField(value: &self.authInfoBytes)
      case 3: try decoder.decodeSingularStringField(value: &self.chainID)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.accountNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if !self.authInfoBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.authInfoBytes, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignDoc, rhs: Cosmos_Tx_V1beta1_SignDoc) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs.authInfoBytes != rhs.authInfoBytes {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_TxBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "memo"),
    3: .standard(proto: "timeout_height"),
    1023: .standard(proto: "extension_options"),
    2047: .standard(proto: "non_critical_extension_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularStringField(value: &self.memo)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.timeoutHeight)
      case 1023: try decoder.decodeRepeatedMessageField(value: &self.extensionOptions)
      case 2047: try decoder.decodeRepeatedMessageField(value: &self.nonCriticalExtensionOptions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 2)
    }
    if self.timeoutHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeoutHeight, fieldNumber: 3)
    }
    if !self.extensionOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extensionOptions, fieldNumber: 1023)
    }
    if !self.nonCriticalExtensionOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonCriticalExtensionOptions, fieldNumber: 2047)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_TxBody, rhs: Cosmos_Tx_V1beta1_TxBody) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.timeoutHeight != rhs.timeoutHeight {return false}
    if lhs.extensionOptions != rhs.extensionOptions {return false}
    if lhs.nonCriticalExtensionOptions != rhs.nonCriticalExtensionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_AuthInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_infos"),
    2: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.signerInfos)
      case 2: try decoder.decodeSingularMessageField(value: &self._fee)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signerInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signerInfos, fieldNumber: 1)
    }
    if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_AuthInfo, rhs: Cosmos_Tx_V1beta1_AuthInfo) -> Bool {
    if lhs.signerInfos != rhs.signerInfos {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "mode_info"),
    3: .same(proto: "sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._publicKey)
      case 2: try decoder.decodeSingularMessageField(value: &self._modeInfo)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.sequence)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._modeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignerInfo, rhs: Cosmos_Tx_V1beta1_SignerInfo) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._modeInfo != rhs._modeInfo {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "single"),
    2: .same(proto: "multi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Cosmos_Tx_V1beta1_ModeInfo.Single?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .single(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .single(v)}
      case 2:
        var v: Cosmos_Tx_V1beta1_ModeInfo.Multi?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .multi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .multi(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.sum {
    case .single(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .multi(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo, rhs: Cosmos_Tx_V1beta1_ModeInfo) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Tx_V1beta1_ModeInfo.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.Single, rhs: Cosmos_Tx_V1beta1_ModeInfo.Single) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo.Multi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Tx_V1beta1_ModeInfo.protoMessageName + ".Multi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bitarray"),
    2: .standard(proto: "mode_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._bitarray)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.modeInfos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bitarray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.modeInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modeInfos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.Multi, rhs: Cosmos_Tx_V1beta1_ModeInfo.Multi) -> Bool {
    if lhs._bitarray != rhs._bitarray {return false}
    if lhs.modeInfos != rhs.modeInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_Fee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Fee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "gas_limit"),
    3: .same(proto: "payer"),
    4: .same(proto: "granter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.amount)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.gasLimit)
      case 3: try decoder.decodeSingularStringField(value: &self.payer)
      case 4: try decoder.decodeSingularStringField(value: &self.granter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 1)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    if !self.granter.isEmpty {
      try visitor.visitSingularStringField(value: self.granter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Fee, rhs: Cosmos_Tx_V1beta1_Fee) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.granter != rhs.granter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
