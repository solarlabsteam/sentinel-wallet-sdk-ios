// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: osmosis/protorev/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParamsRequest is request type for the Query/Params RPC method.
struct Osmosis_Protorev_V1beta1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is response type for the Query/Params RPC method.
struct Osmosis_Protorev_V1beta1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params holds all the parameters of this module.
  var params: Osmosis_Protorev_V1beta1_Params {
    get {return _params ?? Osmosis_Protorev_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Osmosis_Protorev_V1beta1_Params? = nil
}

/// QueryGetProtoRevNumberOfTradesRequest is request type for the
/// Query/GetProtoRevNumberOfTrades RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevNumberOfTradesResponse is response type for the
/// Query/GetProtoRevNumberOfTrades RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number_of_trades is the number of trades the module has executed
  var numberOfTrades: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevProfitsByDenomRequest is request type for the
/// Query/GetProtoRevProfitsByDenom RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denom is the denom to query profits by
  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevProfitsByDenomResponse is response type for the
/// Query/GetProtoRevProfitsByDenom RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// profit is the profits of the module by the selected denom
  var profit: Cosmos_Base_V1beta1_Coin {
    get {return _profit ?? Cosmos_Base_V1beta1_Coin()}
    set {_profit = newValue}
  }
  /// Returns true if `profit` has been explicitly set.
  var hasProfit: Bool {return self._profit != nil}
  /// Clears the value of `profit`. Subsequent reads from it will return its default value.
  mutating func clearProfit() {self._profit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _profit: Cosmos_Base_V1beta1_Coin? = nil
}

/// QueryGetProtoRevAllProfitsRequest is request type for the
/// Query/GetProtoRevAllProfits RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevAllProfitsResponse is response type for the
/// Query/GetProtoRevAllProfits RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// profits is a list of all of the profits from the module
  var profits: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevStatisticsByPoolRequest is request type for the
/// Query/GetProtoRevStatisticsByRoute RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// route is the set of pool ids to query statistics by i.e. 1,2,3
  var route: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevStatisticsByRouteResponse is response type for the
/// Query/GetProtoRevStatisticsByRoute RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// statistics contains the number of trades the module has executed after a
  /// swap on a given pool and the profits from the trades
  var statistics: Osmosis_Protorev_V1beta1_RouteStatistics {
    get {return _statistics ?? Osmosis_Protorev_V1beta1_RouteStatistics()}
    set {_statistics = newValue}
  }
  /// Returns true if `statistics` has been explicitly set.
  var hasStatistics: Bool {return self._statistics != nil}
  /// Clears the value of `statistics`. Subsequent reads from it will return its default value.
  mutating func clearStatistics() {self._statistics = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _statistics: Osmosis_Protorev_V1beta1_RouteStatistics? = nil
}

/// QueryGetProtoRevAllRouteStatisticsRequest is request type for the
/// Query/GetProtoRevAllRouteStatistics RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevAllRouteStatisticsResponse is response type for the
/// Query/GetProtoRevAllRouteStatistics RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// statistics contains the number of trades/profits the module has executed on
  /// all routes it has successfully executed a trade on
  var statistics: [Osmosis_Protorev_V1beta1_RouteStatistics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevTokenPairArbRoutesRequest is request type for the
/// Query/GetProtoRevTokenPairArbRoutes RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevTokenPairArbRoutesResponse is response type for the
/// Query/GetProtoRevTokenPairArbRoutes RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// routes is a list of all of the hot routes that the module is currently
  /// arbitraging
  var routes: [Osmosis_Protorev_V1beta1_TokenPairArbRoutes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevAdminAccountRequest is request type for the
/// Query/GetProtoRevAdminAccount RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevAdminAccountResponse is response type for the
/// Query/GetProtoRevAdminAccount RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// admin_account is the admin account of the module
  var adminAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevDeveloperAccountRequest is request type for the
/// Query/GetProtoRevDeveloperAccount RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevDeveloperAccountResponse is response type for the
/// Query/GetProtoRevDeveloperAccount RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// developer_account is the developer account of the module
  var developerAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevPoolWeightsRequest is request type for the
/// Query/GetProtoRevPoolWeights RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevPoolWeightsResponse is response type for the
/// Query/GetProtoRevPoolWeights RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pool_weights is a list of all of the pool weights
  var poolWeights: Osmosis_Protorev_V1beta1_PoolWeights {
    get {return _poolWeights ?? Osmosis_Protorev_V1beta1_PoolWeights()}
    set {_poolWeights = newValue}
  }
  /// Returns true if `poolWeights` has been explicitly set.
  var hasPoolWeights: Bool {return self._poolWeights != nil}
  /// Clears the value of `poolWeights`. Subsequent reads from it will return its default value.
  mutating func clearPoolWeights() {self._poolWeights = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolWeights: Osmosis_Protorev_V1beta1_PoolWeights? = nil
}

/// QueryGetProtoRevMaxPoolPointsPerBlockRequest is request type for the
/// Query/GetProtoRevMaxPoolPointsPerBlock RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevMaxPoolPointsPerBlockResponse is response type for the
/// Query/GetProtoRevMaxPoolPointsPerBlock RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// max_pool_points_per_block is the maximum number of pool points that can be
  /// consumed per block
  var maxPoolPointsPerBlock: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevMaxPoolPointsPerTxRequest is request type for the
/// Query/GetProtoRevMaxPoolPointsPerTx RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevMaxPoolPointsPerTxResponse is response type for the
/// Query/GetProtoRevMaxPoolPointsPerTx RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// max_pool_points_per_tx is the maximum number of pool points that can be
  /// consumed per transaction
  var maxPoolPointsPerTx: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevBaseDenomsRequest is request type for the
/// Query/GetProtoRevBaseDenoms RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevBaseDenomsResponse is response type for the
/// Query/GetProtoRevBaseDenoms RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// base_denoms is a list of all of the base denoms and step sizes
  var baseDenoms: [Osmosis_Protorev_V1beta1_BaseDenom] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevEnabledRequest is request type for the
/// Query/GetProtoRevEnabled RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevEnabledResponse is response type for the
/// Query/GetProtoRevEnabled RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// enabled is whether the module is enabled
  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevPoolRequest is request type for the
/// Query/GetProtoRevPool RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// base_denom is the base denom set in protorev for the denom pair to pool
  /// mapping
  var baseDenom: String = String()

  /// other_denom is the other denom for the denom pair to pool mapping
  var otherDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGetProtoRevPoolResponse is response type for the
/// Query/GetProtoRevPool RPC method.
struct Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pool_id is the pool_id stored for the denom pair
  var poolID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Osmosis_Protorev_V1beta1_QueryParamsRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryParamsResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledResponse: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolRequest: @unchecked Sendable {}
extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "osmosis.protorev.v1beta1"

extension Osmosis_Protorev_V1beta1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryParamsRequest, rhs: Osmosis_Protorev_V1beta1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryParamsResponse, rhs: Osmosis_Protorev_V1beta1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevNumberOfTradesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevNumberOfTradesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "number_of_trades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.numberOfTrades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.numberOfTrades.isEmpty {
      try visitor.visitSingularStringField(value: self.numberOfTrades, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevNumberOfTradesResponse) -> Bool {
    if lhs.numberOfTrades != rhs.numberOfTrades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevProfitsByDenomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevProfitsByDenomResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevProfitsByDenomResponse) -> Bool {
    if lhs._profit != rhs._profit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevAllProfitsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevAllProfitsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.profits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.profits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.profits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllProfitsResponse) -> Bool {
    if lhs.profits != rhs.profits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevStatisticsByRouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.route, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteRequest) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevStatisticsByRouteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statistics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._statistics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._statistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevStatisticsByRouteResponse) -> Bool {
    if lhs._statistics != rhs._statistics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevAllRouteStatisticsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevAllRouteStatisticsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statistics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.statistics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statistics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statistics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAllRouteStatisticsResponse) -> Bool {
    if lhs.statistics != rhs.statistics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevTokenPairArbRoutesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevTokenPairArbRoutesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevTokenPairArbRoutesResponse) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevAdminAccountRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevAdminAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "admin_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.adminAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adminAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.adminAccount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevAdminAccountResponse) -> Bool {
    if lhs.adminAccount != rhs.adminAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevDeveloperAccountRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevDeveloperAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "developer_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.developerAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.developerAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.developerAccount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevDeveloperAccountResponse) -> Bool {
    if lhs.developerAccount != rhs.developerAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevPoolWeightsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevPoolWeightsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_weights"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolWeights) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolWeights {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolWeightsResponse) -> Bool {
    if lhs._poolWeights != rhs._poolWeights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevMaxPoolPointsPerBlockRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevMaxPoolPointsPerBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_pool_points_per_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxPoolPointsPerBlock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPoolPointsPerBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPoolPointsPerBlock, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerBlockResponse) -> Bool {
    if lhs.maxPoolPointsPerBlock != rhs.maxPoolPointsPerBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevMaxPoolPointsPerTxRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevMaxPoolPointsPerTxResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_pool_points_per_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxPoolPointsPerTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPoolPointsPerTx != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPoolPointsPerTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevMaxPoolPointsPerTxResponse) -> Bool {
    if lhs.maxPoolPointsPerTx != rhs.maxPoolPointsPerTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevBaseDenomsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevBaseDenomsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_denoms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.baseDenoms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseDenoms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.baseDenoms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevBaseDenomsResponse) -> Bool {
    if lhs.baseDenoms != rhs.baseDenoms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevEnabledRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevEnabledResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevEnabledResponse) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevPoolRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_denom"),
    2: .standard(proto: "other_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.otherDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 1)
    }
    if !self.otherDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.otherDenom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolRequest, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolRequest) -> Bool {
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.otherDenom != rhs.otherDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetProtoRevPoolResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolResponse, rhs: Osmosis_Protorev_V1beta1_QueryGetProtoRevPoolResponse) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
